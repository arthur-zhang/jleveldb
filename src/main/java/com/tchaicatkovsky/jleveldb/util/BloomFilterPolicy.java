package com.tchaicatkovsky.jleveldb.util;

import java.util.List;

import com.tchaicatkovsky.jleveldb.FilterPolicy;

public class BloomFilterPolicy extends FilterPolicy {

	final static long kUint32Mask = 0xffffffffL;
	
	int bitsPerKey;
	int k;
	
	final public static long bloomHash(Slice key) {
		return Hash.hash0(key.data(), key.offset(), key.size(), 0xbc9f1d34L) & kUint32Mask;
	}
  
	public BloomFilterPolicy(int bitsPerKey) {
		this.bitsPerKey = bitsPerKey;
		// We intentionally round down to reduce probing cost a little bit
		k = (int)(bitsPerKey * 0.69);  // 0.69 =~ ln(2)
		if (k < 1) k = 1;
		if (k > 30) k = 30;
	}
	
	@Override
	public void delete() {
		
	}
	
	@Override
	public String name() {
		return "leveldb.BuiltinBloomFilter2";
	}

	@Override
	public void createFilter(List<Slice> keys, ByteBuf dst) {
		// Compute bloom filter size (in both bits and bytes)
		int n = keys.size();
	    int bits = n * bitsPerKey;
	    
	    // For small n, we can see a very high false positive rate.  Fix it
	    // by enforcing a minimum bloom filter length.
	    if (bits < 64) bits = 64;
	    
	    int bytes = (bits + 7) / 8;
	    bits = bytes * 8;
	    
	    final int initSize = dst.size();
	    dst.resize(initSize + bytes, (byte)0);
	    dst.addByte((byte)k);  // Remember # of probes in filter
	    byte[] array = dst.data();
	    int offset = initSize;
	    for (int i = 0; i < n; i++) {
	    	// Use double-hashing to generate a sequence of hash values.
	    	// See analysis in [Kirsch,Mitzenmacher 2006].
	    	long h = bloomHash(keys.get(i));
	    	long delta = (((h >> 17) | (h << 15)) & kUint32Mask);  // Rotate right 17 bits
	    	for (int j = 0; j < k; j++) {
	    		final long bitpos = h % bits;
	    		int idx = (int)(offset + bitpos/8);
	    		array[idx] = (byte)((array[idx] | (1 << (bitpos % 8))) & 0xff);
	    		h += delta; h &= kUint32Mask;
	    	}
	    }
	}

	@Override
	public boolean keyMayMatch(Slice key, Slice bloomFilter) {
		final int len = bloomFilter.size();
	    if (len < 2) return false;
	    
	    byte[] array = bloomFilter.data();
	    final int bits = (len - 1) * 8;
	    
	    // Use the encoded k so that we can read filters generated by
	    // bloom filters created using different parameters.
	    final int k = (array[len-1] & 0xff);
	    if (k > 30) {
	    	// Reserved for potentially new encodings for short bloom filters.
	    	// Consider it a match.
	    	return true;
	    }
		
		long h = bloomHash(key);
	    final long delta = (((h >> 17) | (h << 15)) & kUint32Mask);  // Rotate right 17 bits
	    for (int j = 0; j < k; j++) {
	    	final long bitpos = h % bits;
	    	if ((array[(int)(bitpos/8)] & (1 << (bitpos % 8))) == 0) 
	    		return false;
	    	h += delta; h &= kUint32Mask;
	    }
	    return true;
	}
}
