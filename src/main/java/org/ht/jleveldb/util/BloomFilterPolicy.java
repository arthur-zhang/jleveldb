package org.ht.jleveldb.util;

import org.ht.jleveldb.FilterPolicy;

//TODO: test
public class BloomFilterPolicy extends FilterPolicy {

	int bitsPerKey;
	int k;
	
	public static int bloomHash(Slice key) {
		return Hash.hash0(key.data, key.offset, key.size(), 0xbc9f1d34);
	}
  
	public BloomFilterPolicy(int bitsPerKey) {
		this.bitsPerKey = bitsPerKey;
		// We intentionally round down to reduce probing cost a little bit
		k = (int)(bitsPerKey * 0.69);  // 0.69 =~ ln(2)
		if (k < 1) k = 1;
		if (k > 30) k = 30;
	}
	
	@Override
	public String name() {
		return "leveldb.BuiltinBloomFilter2";
	}

	@Override
	public void createFilter(Slice[] keys, int n, ByteBuf dst) {
		// Compute bloom filter size (in both bits and bytes)
	    int bits = n * bitsPerKey;
	    
	    // For small n, we can see a very high false positive rate.  Fix it
	    // by enforcing a minimum bloom filter length.
	    if (bits < 64) bits = 64;
	    
	    int bytes = (bits + 7) / 8;
	    bits = bytes * 8;
	    
	    final int initSize = dst.size();
	    dst.resize(initSize + bytes, (byte)0);
	    dst.addByte((byte)k);  // Remember # of probes in filter
	    //char* array = &(*dst)[init_size];
	    byte[] array = dst.data();
	    int offset = initSize;
	    for (int i = 0; i < n; i++) {
	    	// Use double-hashing to generate a sequence of hash values.
	    	// See analysis in [Kirsch,Mitzenmacher 2006].
	    	int h = bloomHash(keys[i]);
	    	final int delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
	    	for (int j = 0; j < k; j++) {
	    		final int bitpos = h % bits;
	    		array[offset + bitpos/8] |= ((1 << (bitpos % 8)) & 0xff);
	    		h += delta;
	    	}
	    }
	}

	@Override
	public boolean keyMayMatch(Slice key, Slice bloomFilter) {
		final int len = bloomFilter.size();
	    if (len < 2) return false;
	    
	    byte[] array = bloomFilter.data();
	    final int bits = (len - 1) * 8;
	    
	    // Use the encoded k so that we can read filters generated by
	    // bloom filters created using different parameters.
	    final int k = array[len-1];
	    if (k > 30) {
	    	// Reserved for potentially new encodings for short bloom filters.
	    	// Consider it a match.
	    	return true;
	    }
		
		int h = bloomHash(key);
	    final int delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
	    for (int j = 0; j < k; j++) {
	    	final int bitpos = h % bits;
	    	if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
	    	h += delta;
	    }
	    return true;
	}
}
